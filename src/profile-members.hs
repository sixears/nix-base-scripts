{-# OPTIONS_GHC -W -Wall -Wno-deprecations -fhelpful-errors #-}
{-# LANGUAGE DeriveAnyClass             #-}
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase                 #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE TypeSynonymInstances       #-}
{-# LANGUAGE TupleSections              #-}
{-# LANGUAGE UnicodeSyntax              #-}
{-# LANGUAGE ViewPatterns               #-}

import Base1T

-- aeson -------------------------------

import Data.Aeson  ( FromJSON, eitherDecodeFileStrict' )

-- base --------------------------------

import qualified  Data.List.NonEmpty  as  NonEmpty

import Data.Char      ( isAlpha, isAlphaNum )
import Data.List      ( reverse, zip )
import Data.Maybe     ( fromMaybe )
import GHC.Generics   ( Generic )
import System.IO      ( hPutStrLn, stderr )

-- fpath -------------------------------

import qualified FPath.Parseable

import FPath.AbsDir            ( AbsDir, absdir, parseAbsDirP, parseAbsDirP' )
import FPath.AbsFile           ( AbsFile )
import FPath.AppendableFPath   ( (‚´ª) )
import FPath.AsFilePath        ( filepath )
import FPath.AsFilePath'       ( filepath' )
import FPath.RelDir            ( reldir )
import FPath.RelFile           ( relfile )
import FPath.Error.FPathError  ( AsFPathError )

-- log-plus ----------------------------

import Log  ( Log )

-- logging-effect ----------------------

import Control.Monad.Log  ( LoggingT, MonadLog, Severity( Informational ) )

-- mockio ------------------------------

import MockIO.DoMock  ( DoMock( NoMock ), HasDoMock )

-- mockio-log --------------------------

import MockIO.IOClass      ( HasIOClass )
import MockIO.MockIOClass  ( MockIOClass )

-- mockio-plus -------------------------

import MockIO.File  ( fexists )

-- monadio-plus ------------------------

import MonadIO.Base   ( getArgs )
import MonadIO.FStat  ( FExists( FExists, NoFExists ) )

-- more-unicode ------------------------

import Data.MoreUnicode.Monad  ( (‚ãò) )

-- optparse-applicative ----------------

import Options.Applicative.Builder  ( flag, help, long, metavar, short
                                    , strArgument )
import Options.Applicative.Types    ( Parser )

-- parsers -----------------------------

import Text.Parser.Char         ( CharParsing, alphaNum, char, digit, noneOf
                                , satisfy, string )
import Text.Parser.Combinators  ( count,optional,sepByNonEmpty,try,unexpected )

-- stdmain -----------------------------

import StdMain             ( stdMainNoDR )
import StdMain.UsageError  ( AsUsageError, UsageFPIOTPError )

-- text --------------------------------

import Data.Text     ( intercalate, pack, unpack, unsnoc )
import Data.Text.IO  ( putStrLn )

-- text-printer ------------------------

import qualified  Text.Printer  as  P

-- textual-plus ------------------------

import TextualPlus  ( TextualPlus( textual' ), parseText, tparse )
import TextualPlus.Error.TextualParseError
                    ( AsTextualParseError, TextualParseError, tparseToME' )

-- unix --------------------------------

import System.Posix.User  ( UserEntry, getEffectiveUserName, getUserEntryForName
                          , homeDirectory )

--------------------------------------------------------------------------------

data ShowVersion = ShowVersion | NoShowVersion
data ShowIndex   = ShowIndex   | NoShowIndex
data ShowPath    = ShowPath    | NoShowPath

data Options = Options { showVersion ‚à∑ ShowVersion
                       , showIndex   ‚à∑ ShowIndex
                       , showPath    ‚à∑ ShowPath
                       , profileName ‚à∑ ùïÑ ùïã
                       }

parseOptions ‚à∑ Parser Options
parseOptions =
  let version_help  = "show version information, too"
      path_help     = "show store path, too"
      no_index_help = "don't show profile position indices"
  in  Options ‚ä≥ flag NoShowVersion ShowVersion (—é [ short 'v', long "version"
                                                  , help version_help ])
              ‚äµ flag ShowIndex     NoShowIndex (—é [ short 'n', long "no-index"
                                                  , help no_index_help ])
              ‚äµ flag NoShowPath    ShowPath    (—é [ short 'p', long "path"
                                                  , help path_help ])
              ‚äµ optional (strArgument (—é [ metavar "PROFILE-NAME"
                                         , help "profile to enumerate" ]))

------------------------------------------------------------

data AttrPath = AttrPath { _attrPrefixParts ‚à∑ [ùïã], _pkg ‚à∑ Pkg }
  deriving (Eq,Show)

instance Printable AttrPath where
  print (AttrPath ps p) = P.text $ intercalate "." (ps ‚äï [unPkg p])

instance TextualPlus AttrPath where
  textual' =
    ((\ (x :| xs) ‚Üí
          AttrPath (reverse xs) (Pkg x)) ‚àò NonEmpty.reverse ‚àò fmap pack) ‚ä≥
      sepByNonEmpty (some (noneOf ".")) (char '.')

checkT ‚à∑ (TextualPlus Œ±, Eq Œ±, Show Œ±) ‚áí ùïã ‚Üí Œ± ‚Üí TestTree
checkT input exp =
  testCase ("parseText: " ‚äï unpack input) $
    ùïΩ exp @=? (tparseToME' ‚àò parseText) input

attrPathTests ‚à∑ TestTree
attrPathTests =
  testGroup "attrPath"
    [ checkT "packages.x86_64-linux.pia"
            (AttrPath ["packages","x86_64-linux"] (Pkg "pia"))
    , checkT "packages.x86_64-linux.nix-prefetch-github"
            (AttrPath ["packages","x86_64-linux"] (Pkg "nix-prefetch-github"))
    ]

------------------------------------------------------------

data StorePath = StorePath { _path' ‚à∑ AbsDir
                           , _hash  ‚à∑ Hash
                           , _pkg'  ‚à∑ Pkg
                           , _ver   ‚à∑ ùïÑ Ver
                           }
  deriving (Eq,Show)

{-| Match against a store path, e.g.,

    /nix/store/0dbkb5963hjgg45yw07sk3dm43jci4bw-atreus-1.0.2.0

   return hash, pkg, (maybe) ver
-}
storePathRE ‚à∑ CharParsing Œ∑ ‚áí Œ∑ (Hash, Pkg, ùïÑ Ver)
storePathRE =
  let
    pkgRE ‚à∑ CharParsing Œ∑ ‚áí Œ∑ (ùïä, ùïÑ ùïä)
    pkgRE =
      let
        alpha_under_score      ‚à∑ CharParsing Œ∑ ‚áí Œ∑ ‚ÑÇ
        alpha_under_score      = satisfy (\ c ‚Üí isAlpha c ‚à® c ‚â° '_')
        non_hyphen             ‚à∑ CharParsing Œ∑ ‚áí Œ∑ ‚ÑÇ
        non_hyphen             = satisfy (\ c ‚Üí isAlphaNum c ‚à® c ‚àà "_.")
        simple_identifier      ‚à∑ CharParsing Œ∑ ‚áí Œ∑ ùïä
        simple_identifier      = (:) ‚ä≥ alpha_under_score ‚äµ many non_hyphen
        hyphenated_identifiers ‚à∑ CharParsing Œ∑ ‚áí Œ∑ ùïä
        hyphenated_identifiers =
          —é ‚ä≥ ((:) ‚ä≥ simple_identifier ‚äµmany(try $ char '-' ‚ã´simple_identifier))
        numeric_identifier     ‚à∑ CharParsing Œ∑ ‚áí Œ∑ ùïä
        numeric_identifier     =
          (:) ‚ä≥ digit ‚äµ many (satisfy (\ c ‚Üí isAlphaNum c ‚à® c ‚àà "-_."))
      in
        ((,) ‚ä≥ hyphenated_identifiers ‚äµ optional(char '-' ‚ã´ numeric_identifier))
  in
    (\ h (p,v) ‚Üí (Hash (pack h), Pkg (pack p), (Ver ‚àò pack) ‚ä≥ v)) ‚ä≥
      (string "/nix/store/" ‚ã´ count 32 alphaNum) ‚äµ (char '-' ‚ã´ pkgRE)

instance Printable StorePath where
  print (StorePath _ h p v) =
    let v' = case v of ùïπ ‚Üí ""; ùïµ v_ ‚Üí "-" ‚äï unVer v_
    in  P.text $ [fmt|/nix/store/%T-%T-%T/|] h p v'

instance TextualPlus StorePath where
  textual' = do
    let construct p h v =
          either (unexpected ‚àò toString) pure $ parseAbsDirP' @_ @(ùîº _) $
            —é [ "/nix/store/"
               , (unHash h)
               , "-", (unPkg p)
               , maybe "" ("-" ‚äï) ((unVer) ‚ä≥ v)
               ]
    (h,p,v) ‚Üê storePathRE
    t ‚Üê construct p h v
    return (StorePath t h p v)

storePathTests ‚à∑ TestTree
storePathTests =
  testGroup "storePath"
    [ let
        hash          = Hash "0dbkb5963hjgg45yw07sk3dm43jci4bw"
        dirname       =
          [reldir|0dbkb5963hjgg45yw07sk3dm43jci4bw-atreus-1.0.2.0/|]
        path ‚à∑ AbsDir = [absdir|/nix/store/|] ‚´ª dirname
        path'         = pack $ path ‚´• filepath'
      in
        checkT path' (StorePath { _path' = path
                                , _hash  = hash
                                , _pkg'  = Pkg "atreus"
                                , _ver   = ùïµ (Ver "1.0.2.0") })
    , let
        hash          = Hash "g9zcvd6f5aasrxwm48bdbks3scv46b6x"
        dirname       =
          [reldir|g9zcvd6f5aasrxwm48bdbks3scv46b6x-jq-1.6-bin/|]
        path ‚à∑ AbsDir = [absdir|/nix/store/|] ‚´ª dirname
        path'         = pack $ path ‚´• filepath'
      in
        checkT path' (StorePath { _path' = path
                                , _hash  = hash
                                , _pkg'  = Pkg "jq"
                                -- the use of -bin in the version is
                                -- unsatisfying; but I can't see how to
                                -- distinguish from e.g., bash-5.1-p16, where
                                -- p16 *is* part of the version
                                , _ver   = ùïµ (Ver "1.6-bin") })
    ]

spPkgVerPath ‚à∑ StorePath ‚Üí (Pkg, ùïÑ Ver, AbsDir)
spPkgVerPath sp = (_pkg' sp, _ver sp, _path' sp)

------------------------------------------------------------

getEffectiveUserEntry ‚à∑ (AsIOError Œµ, MonadError Œµ Œº, MonadIO Œº) ‚áí Œº UserEntry
getEffectiveUserEntry = asIOError $ getEffectiveUserName ‚â´ getUserEntryForName

getEffectiveHomeDir ‚à∑ (AsIOError Œµ, AsFPathError Œµ, MonadError Œµ Œº, MonadIO Œº) ‚áí
                      Œº AbsDir
getEffectiveHomeDir =
  let getEffectiveUserHomeDir ‚à∑ (AsIOError Œµ, MonadError Œµ Œº, MonadIO Œº) ‚áí Œº ùïä
      getEffectiveUserHomeDir = homeDirectory ‚ä≥ getEffectiveUserEntry
  in  getEffectiveUserHomeDir ‚â´ parseAbsDirP

nixProfile ‚à∑ (AsIOError Œµ,AsFPathError Œµ,MonadError Œµ Œº,MonadIO Œº) ‚áí Œº AbsDir
nixProfile = (‚´ª [reldir|.nix-profile/|]) ‚ä≥ getEffectiveHomeDir

nixProfiles ‚à∑ (AsIOError Œµ,AsFPathError Œµ,MonadError Œµ Œº,MonadIO Œº) ‚áí Œº AbsDir
nixProfiles = (‚´ª [reldir|.nix-profiles/|]) ‚ä≥ getEffectiveHomeDir

throwUserError ‚à∑ ‚àÄ Œµ œÑ Œ± Œ∑ . (Printable œÑ,AsIOError Œµ,MonadError Œµ Œ∑) ‚áí œÑ ‚Üí Œ∑ Œ±
throwUserError = throwError ‚àò userE ‚àò toString

profileManifest ‚à∑ ‚àÄ Œµ œÑ œâ Œº .
                  (AsIOError Œµ, AsFPathError Œµ, Printable Œµ, MonadError Œµ Œº,
                   HasIOClass œâ, HasDoMock œâ, Default œâ, MonadLog (Log œâ) Œº,
                   Printable œÑ, MonadIO Œº) ‚áí
                  œÑ ‚Üí Œº AbsFile
profileManifest (toText ‚Üí d) = do
  dir ‚Üê case unsnoc d of
    ùïπ          ‚Üí nixProfile
    ùïµ (_, c) ‚Üí do d' ‚Üê FPath.Parseable.parse (d ‚äï case c of '/' ‚Üí ""; _ ‚Üí "/")
                  nixProfiles ‚ä≤ (‚´ª d')

  fexists Informational FExists dir NoMock ‚â´ \ case
    NoFExists ‚Üí throwUserError $ [fmtT|No such profile dir '%T'|] dir
    FExists   ‚Üí let manifest_json = [relfile|manifest.json|]
                    manifest      = dir ‚´ª manifest_json
                in  fexists Informational FExists manifest NoMock ‚â´ \ case
                      FExists   ‚Üí return manifest
                      NoFExists ‚Üí throwUserError $
                                    [fmtT|profile dir '%T' lacks a %T|]
                                    dir manifest_json

data Element = Element { active      ‚à∑ ùîπ
                       , priority    ‚à∑ ‚Ñï
                       , storePaths  ‚à∑ NonEmpty ùïä
                       , attrPath    ‚à∑ ùïÑ ùïä
                       , originalURL ‚à∑ ùïÑ ùïä
                       , url         ‚à∑ ùïÑ ùïä
                       }
  deriving (Generic, Show)

instance FromJSON Element

data Manifest = Manifest { version ‚à∑ ‚Ñ§, elements ‚à∑ [Element] }
  deriving (Generic, Show)

{-| elements in a manifest, along with a zero-based index -}
elementsi ‚à∑ Manifest ‚Üí [(‚Ñï,Element)]
elementsi m = zip [0..] (elements m)

instance FromJSON Manifest

newtype Hash = Hash { unHash ‚à∑ ùïã } deriving newtype (Eq,Printable,Show)
newtype Pkg  = Pkg  { unPkg  ‚à∑ ùïã } deriving newtype (Eq,Printable,Show)
newtype Ver  = Ver  { unVer  ‚à∑ ùïã } deriving newtype (Eq,Printable,Show)

------------------------------------------------------------

getNameVerPath ‚à∑ (MonadError TextualParseError Œ∑) ‚áí
                 Element ‚Üí Œ∑ (Pkg, ùïÑ Ver, AbsDir)
getNameVerPath e = do
  (pkgs,ver,path) ‚Üê spPkgVerPath ‚ä≥ tparse (NonEmpty.head $ storePaths e)
  case attrPath e of
    ùïµ ap ‚Üí (,ver,path) ‚ä≥ (_pkg ‚ä≥ tparse ap)
    ùïπ    ‚Üí return (pkgs,ver,path)

output_data ‚à∑ Options ‚Üí Manifest ‚Üí IO ()
output_data options manifest =
  let pShow ‚à∑ Show Œ± ‚áí Œ± ‚Üí IO ()
      pShow = hPutStrLn stderr ‚àò show

      get_columns i n v p = —é [ case showIndex options of
                                  ShowIndex   ‚Üí [pack $ show i]
                                  NoShowIndex ‚Üí []
                              , [toText n]
                              , case showVersion options of
                                  ShowVersion   ‚Üí [maybe "" toText v]
                                  NoShowVersion ‚Üí []
                              , case showPath options of
                                  ShowPath   ‚Üí [toText p]
                                  NoShowPath ‚Üí []
                              ]

      print_name_ver (i,e) = do
        case getNameVerPath e of
          ùï∑ err     ‚Üí pShow err
          ùïΩ (n,v,p) ‚Üí putStrLn (intercalate "\t" $ get_columns i n v p)

  in forM_ (elementsi manifest) print_name_ver

readManifest ‚à∑ ‚àÄ Œµ œÑ œâ Œº .
               (AsIOError Œµ, AsFPathError Œµ, Printable Œµ, MonadError Œµ Œº,
                HasIOClass œâ, HasDoMock œâ, Default œâ, MonadLog (Log œâ) Œº,
                Printable œÑ, MonadIO Œº) ‚áí
               œÑ ‚Üí Œº (Either ùïä Manifest)
readManifest =
  liftIO ‚àò eitherDecodeFileStrict' ‚àò (‚´• filepath) ‚ãò profileManifest

myMain ‚à∑ ‚àÄ Œµ . (HasCallStack, Printable Œµ, AsUsageError Œµ,
                AsTextualParseError Œµ, AsIOError Œµ, AsFPathError Œµ) ‚áí
         Options ‚Üí LoggingT (Log MockIOClass) (ExceptT Œµ IO) Word8
myMain options = do
  -- Strict' version performs conversion immediately
  readManifest (fromMaybe "" $ profileName options) ‚â´ \ case
    ùï∑ e ‚Üí liftIO $ hPutStrLn stderr $ show e
    ùïΩ stuff ‚Üí liftIO $ output_data options stuff
  return 0

main ‚à∑ IO ()
main = do
  let progDesc = "queue executions"
  getArgs ‚â´ stdMainNoDR progDesc parseOptions (myMain @UsageFPIOTPError)

-- tests -----------------------------------------------------------------------

tests ‚à∑ TestTree
tests = testGroup "profile-members"
                  [ attrPathTests, storePathTests ]

_test ‚à∑ IO ExitCode
_test = runTestTree tests

_tests ‚à∑ ùïä ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ ùïä ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------
